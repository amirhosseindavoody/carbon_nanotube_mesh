import numpy as np
from scipy import interpolate
import matplotlib.pyplot as plt

"""
# Definition of tube class
"""

class tube:
  """
  This class actually describes a CNT fiber.
  """

  # constructor
  def __init__(self, coordinates, scaleFactor=10):
    r = np.zeros((0,3))
    for node in coordinates:
        node = node.split(',')
        if (len(node) is 3):
            a = np.array([float(item) for item in node])
            a = a.reshape((1,3))
            r = np.concatenate((r, a), axis=0)
    self.r = r
    self.scale(scaleFactor)

  # calculate interpolated coordinates for tubes
  def calculate_r_fine(self):
    """
    ## Interpolate 3D curve
    We used B-spline functions to interpolate rough meshes generated by BulletPhysics library.

    ### Spline functions
    **Order**: A spline function of order n is a piecewise polynomial function of degree n-1 in a variable x.

    **Knots**: The places where the pieces meet are known as knots.

    ### Implementation

    Use `scipy.interpolate` package to calculate spline parameters ans later one evaluate spline curves using calculated parameters.

    - `splprep` is used to calculated spline parameters:

        - The normal output is a 3-tuple, `(t, c, k)`, containing the knot-points, `t`, the coefficients `c` and the order `k` of the spline.
        - The output `u` is the parameter array, which would produce the equivalent of input points for calculating the spline curves.
        - `x_test, y_test, z_test = interpolate.splev(u, tck)` would produce such points in 3d space.

    - `splev(x, tck, der=0, ext=0)` <br> Evaluate a B-spline or its derivatives. Given the knots and coefficients of a B-spline representatio, evaluate the value of the smoothing polynomial and its derivatives.

    Look here for more: https://stackoverflow.com/questions/18962175/spline-interpolation-coefficients-of-a-line-curve-in-3d-space
    """
    tck, u = interpolate.splprep([self.r[:,0], self.r[:,1], self.r[:,2]], s=500, k=3)
    u_fine = np.linspace(0,1,100)
    x_fine, y_fine, z_fine = interpolate.splev(u_fine, tck)
    r_fine = np.vstack((x_fine,y_fine,z_fine)).T
    self._r_fine = r_fine
    self._tck, self._u = tck, u

  # getter function for interpolated coordinates
  # def r_fine(self):
  #   if not hasattr(self,'_r_fine'):
  #     self.calculate_r_fine()
  #   return self._r_fine

  # getter function for interpolated coordinates
  def r_fine(self):
    if hasattr(self, '_r_fine'):
      return self._r_fine
    self.calculate_r_fine()
    return self._r_fine

  def tangent_vec(self):
    """
    Returns
    -------
    tangent_vec : normalized tangent vectors at the interpolated points, output has shape (N,3)
    """
    tck = self._tck
    u_fine = np.linspace(0, 1, self.r_fine().shape[0])
    deriv_x, deriv_y, deriv_z = interpolate.splev(u_fine, tck, der=1)
    tangent_vec = np.vstack((deriv_x, deriv_y, deriv_z)).T
    
    normalize = lambda v: v/np.linalg.norm(v)
    return np.apply_along_axis(normalize, axis=1, arr=tangent_vec)

  # scale coordinates of tubes by a constant factor
  def scale(self, factor=10):
    if hasattr(self,'_r_fine'):
      del self._r_fine
    self.r = 10*self.r

  # get average of y coordinates
  def avg_y(self):
    return np.mean(self.y())

  # getter methods for coarse coordinates
  def x(self):
    return self.r[:,0]
  def y(self):
    return self.r[:,1]
  def z(self):
    return self.r[:,2]

  # getter methods for interpolated coordinates
  def x_fine(self):
    return self.r_fine()[:,0]
  def y_fine(self):
    return self.r_fine()[:,1]
  def z_fine(self):
    return self.r_fine()[:,2]

  # plot the tube
  def plot(self,ax=None,mode='true'):
    assert mode is 'true' or 'fine'

    if ax is None:
      fig = plt.figure(figsize=(12,10))
      ax = fig.add_subplot(111, projection='3d')

    if mode is 'true':
      x, y, z = self.x(), self.y(), self.z()
    elif mode is 'fine':
      x, y, z = self.x_fine(), self.y_fine(), self.z_fine()

    ax.plot(z,x,y)
    return ax

